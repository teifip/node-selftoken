# node-selftoken

Generation and verification of integrity-protected and time-constrained tokens usable when directing a user through a web-based workflow.

For example, web pages part of the workflow can include a hidden form field to pass validated context information from one page to another when the user completes a submission:

```html
<form>
  <input type="hidden" name="continue" value="#token#">

</form>
```

Tokens generated by `node-selftoken` are inspired to the principles set forth with [JWS](https://tools.ietf.org/html/rfc7515) and [JWT](https://tools.ietf.org/html/rfc7519). However, they deliberately differ from the standards for the following reasons:
* The target use case assumes that the tokens are both generated and validated by the same server, thus making unnecessary to have any type of header/descriptor embedded in the tokens themselves;
* The target use case requires a moderate level of protection, which can be achieved with a limited number of options.

Tokens generated by `node-selftoken` are integrity-protected, not encrypted. The input string is obfuscated through the use of [URL-safe base64 encoding](https://tools.ietf.org/html/rfc4648#section-5) but remains accessible. Integrity-protection is provided through a [SHA-256 HMAC](https://tools.ietf.org/html/rfc4648#section-5) truncated to 16-octets. The HMAC key is derived from a 32-octet long-term password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) with [SHA-256 digest](https://en.wikipedia.org/wiki/SHA-2). A new 16-octet salt is randomly generated for each new token and embedded in the token itself.

## Installation
```
$ npm install node-selftoken
```
The package has no dependencies.

## Token handler instantiation

Instantiate a token handler as follows:
```javascript
const TokenHandler = require('node-selftoken');

var options: {
  tokenLifecycle: 180,
  pbkdf2Iterations: 1
}

var selftoken = new TokenHandler(options);
```
If the `options` object is omitted, then default values are used for all the parameters.

The following options are defined:

| Options            | Use   |
|--------------------|-------|
| `tokenLifecycle`   | Validity of the tokens in seconds; default value is `180` (corresponding to 3 minutes); token validation fails after the token validity has expired
| `pbkdf2Iterations` | Number of SHA-256 iterations used to derive the signature key from the long-term password; default value is `1` to save resources; a decent level of protection is anyhow provided by the use of a different random salt at each token generation

The long-term password is auto-generated when the token handler is instatiated. Therefore, there is no option to configure it.

## Token handler use

All APIs are asynchronous.

**selftoken.generate(inputString, callback)**

---

The callback returns either an error or the newly generated token. Example:
```javascript
selftoken.generate(inputString, (error, token) => {

  console.log('Here is the token:', token);

});
```
**selftoken.verify(token, callback)**

---

The callback returns either an error or the validated string extracted from the token. Example:

```javascript
selftoken.verify(token, (error, outputString) => {

  console.log('Here is the validated string:', outputString);

});
```
Note than token validation fails - and an error is returned - both in case the token has been tampered and in case the token has expired.
