# node-selftoken

Generation and verification of integrity-protected and time-constrained tokens usable when directing a user through a web-based workflow.

For example, web pages part of the workflow can include a hidden form input field to pass validated context information from one page to another when the user completes a submission:

```html
<form>
  <input type="hidden" name="continue" value="#token#">

</form>
```

Tokens generated by `node-selftoken` are inspired to the principles set forth with [JWS](https://tools.ietf.org/html/rfc7515) and [JWT](https://tools.ietf.org/html/rfc7519). However, they deliberately differ from the [JOSE](https://datatracker.ietf.org/wg/jose/documents/) standards for the following reasons:
* The target use case assumes that the tokens are both generated and validated by the same server, thus making unnecessary any type of header/descriptor embedded in the tokens themselves;
* The target use case requires a moderate level of protection, which can be achieved with a limited number of options.

Tokens generated by `node-selftoken` are integrity-protected, not encrypted. The input string is obfuscated through the use of [URL-safe base64 encoding](https://tools.ietf.org/html/rfc4648#section-5) but remains accessible. Integrity-protection is provided through a [SHA-256 HMAC](https://tools.ietf.org/html/rfc4648#section-5) truncated to 16-octets. The HMAC key is derived from a 32-octet long-term password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) with [SHA-256 digest](https://en.wikipedia.org/wiki/SHA-2). A new 16-octet salt is randomly generated for each new token and embedded in the token itself.

## Installation
```
$ npm install node-selftoken
```
The package has no dependencies.

## Token handler instantiation

Instantiate a `selftoken` handler as follows:
```javascript
const TokenHandler = require('node-selftoken');

var options: {
  tokenLifecycle: 180,
  pbkdf2Iterations: 1
}

var selftoken = new TokenHandler(options);
```
If the `options` object is omitted, then default values are used for all the parameters.

The following options are defined:

| Options            | Use   |
|--------------------|-------|
| `tokenLifecycle`   | Validity of the tokens in seconds; default value is `180` seconds (3 minutes); token validation fails after the token validity has expired
| `pbkdf2Iterations` | Number of SHA-256 iterations used to derive the HMAC key from the long-term password; default value is `1` to save resources; a decent level of protection of the long-term password is anyhow provided by the use of a different random salt at each token generation

The long-term password is auto-generated when the token handler is instatiated. Therefore, there is no option to configure it.

## Token handler use

All the APIs are asynchronous.

**selftoken.generate(inputString, callback)**

---

The callback returns either an error or the newly generated token. Example:
```javascript
selftoken.generate(inputString, (error, token) => {

  console.log('Here is the token:', token);

});
```
There are no plausible reasons for errors if the token generation API is correctly called with a string as input parameter. Therefore, the error return value can be loosely managed.

**selftoken.verify(token, callback)**

---

The callback returns either an error or the validated string extracted from the token. Example:

```javascript
selftoken.verify(token, (error, outputString) => {

  console.log('Here is the validated string:', outputString);

});
```
Note than token validation fails - and an error is returned - both in case the token has been tampered and in case the token has expired.

One case in which a web workflow token may expire if when the user leaves the workflow unattended for longer than acceptable (e.g. by not completing a submission). Therefore, the most common reaction to an expired token is to direct the user to go back to the beginning of the workflow and start again.

## Token length

For a given string, tokens generated by `node-selftoken` have size comparable to that of the base64-encoding of the string. The following example can be used for reference.

Object to be conveyed through the token:
```javascript
var example = {
  transactionId: '123e4567-e89b-12d3-a456-426655440000',
  paymentId: '550e8400-e29b-11d4-a716-446655440000',
  user: 'mailto:jack.sparrow@example.com'
}
```
The use of `JSON.stringify(example)` produces a 148-character string, which represents the payload of the token.

```javascript
var payload = JSON.stringify(example);

console.log(payload.length);
// 148

console.log(Buffer.from(payload).toString('base64').length);
// 200

selftoken.generate(payload, (error, token) => {
  console.log(token);
  // eyJwIjoie1widHJhbnNhY3Rpb25JZFwiOlwiMTIzZTQ1NjctZTg5Yi0xMmQzLWE0NTYtNDI2NjU1NDQwMDAwXCIsXCJwYXltZW50SWRcIjpcIjU1MGU4NDAwLWUyOWItMTFkNC1hNzE2LTQ0NjY1NTQ0MDAwMFwiLFwidXNlclwiOlwibWFpbHRvOmphY2suc3BhcnJvd0BleGFtcGxlLmNvbVwifSIsImUiOjE0NzgxNDU5MDU1MzB9.Cp8jJnUiR4YQXnAnGmtnI8NyCBU6JwCU5xjKmBrgDAk
  console.log(token.length);
  // 292
});
```
The longer the payload, the more negligible the difference in size between the token and the simple base64-encoding.
